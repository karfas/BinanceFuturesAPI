# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.

struct MarketApi <: OpenAPI.APIClientImpl
    client::OpenAPI.Clients.Client
end

"""
The default API base path for APIs in `MarketApi`.
This can be used to construct the `OpenAPI.Clients.Client` instance.
"""
basepath(::Type{ MarketApi }) = "http://}"

const _returntypes_basis_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_basis(_api::MarketApi; pair=nothing, contract_type=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_basis_MarketApi, "/futures/data/basis", [])
    OpenAPI.Clients.set_param(_ctx.query, "pair", pair)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "contractType", contract_type)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "period", period)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Basis

Basis

Params:
- pair::String
- contract_type::String
- period::String
- limit::String
- start_time::String
- end_time::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function basis(_api::MarketApi; pair=nothing, contract_type=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_basis(_api; pair=pair, contract_type=contract_type, period=period, limit=limit, start_time=start_time, end_time=end_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function basis(_api::MarketApi, response_stream::Channel; pair=nothing, contract_type=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_basis(_api; pair=pair, contract_type=contract_type, period=period, limit=limit, start_time=start_time, end_time=end_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_check_server_time_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_check_server_time(_api::MarketApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_check_server_time_MarketApi, "/fapi/v1/time", [])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Check Server Time

Check Server Time 

Params:

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function check_server_time(_api::MarketApi; _mediaType=nothing)
    _ctx = _oacinternal_check_server_time(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function check_server_time(_api::MarketApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_check_server_time(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_composite_index_symbol_information_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_composite_index_symbol_information(_api::MarketApi; symbol=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_composite_index_symbol_information_MarketApi, "/fapi/v1/indexInfo", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.header, "x-mbx-apikey", x_mbx_apikey)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Composite Index Symbol Information

Composite Index Symbol Information

Params:
- symbol::String
- x_mbx_apikey::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function composite_index_symbol_information(_api::MarketApi; symbol=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_composite_index_symbol_information(_api; symbol=symbol, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function composite_index_symbol_information(_api::MarketApi, response_stream::Channel; symbol=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_composite_index_symbol_information(_api; symbol=symbol, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_compressed_aggregate_trades_list_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{AggregateTradesResponseInner},
)

function _oacinternal_compressed_aggregate_trades_list(_api::MarketApi, symbol::String; from_id=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    OpenAPI.validate_param("limit", "compressed_aggregate_trades_list", :maximum, limit, 1000, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_compressed_aggregate_trades_list_MarketApi, "/fapi/v1/aggTrades", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "fromId", from_id)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Compressed/Aggregate Trades List

Get compressed, aggregate trades. Trades that fill at the same time, from the same order, with the same price will have the quantity aggregated.

Params:
- symbol::String (required)
- from_id::Int64
- start_time::Int64
- end_time::Int64
- limit::Int64

Return: Vector{AggregateTradesResponseInner}, OpenAPI.Clients.ApiResponse
"""
function compressed_aggregate_trades_list(_api::MarketApi, symbol::String; from_id=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_compressed_aggregate_trades_list(_api, symbol; from_id=from_id, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function compressed_aggregate_trades_list(_api::MarketApi, response_stream::Channel, symbol::String; from_id=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_compressed_aggregate_trades_list(_api, symbol; from_id=from_id, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_continuous_contract_kline_candlestick_data_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{Vector{KlinesResponseInnerInner}},
)

function _oacinternal_continuous_contract_kline_candlestick_data(_api::MarketApi; pair=nothing, contract_type=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_continuous_contract_kline_candlestick_data_MarketApi, "/fapi/v1/continuousKlines", [])
    OpenAPI.Clients.set_param(_ctx.query, "pair", pair)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "contractType", contract_type)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "interval", interval)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Continuous Contract Kline/Candlestick Data

Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.

Params:
- pair::String
- contract_type::String
- interval::String
- start_time::String
- end_time::String
- limit::String

Return: Vector{Vector{KlinesResponseInnerInner}}, OpenAPI.Clients.ApiResponse
"""
function continuous_contract_kline_candlestick_data(_api::MarketApi; pair=nothing, contract_type=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_continuous_contract_kline_candlestick_data(_api; pair=pair, contract_type=contract_type, interval=interval, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function continuous_contract_kline_candlestick_data(_api::MarketApi, response_stream::Channel; pair=nothing, contract_type=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_continuous_contract_kline_candlestick_data(_api; pair=pair, contract_type=contract_type, interval=interval, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_exchange_information_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ExchangeInfoResponse,
)

function _oacinternal_exchange_information(_api::MarketApi; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_exchange_information_MarketApi, "/fapi/v1/exchangeInfo", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "symbols", symbols)  # type Vector{String}
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Exchange Information

Exchange Information 

Params:
- symbol::String
- symbols::Vector{String}

Return: ExchangeInfoResponse, OpenAPI.Clients.ApiResponse
"""
function exchange_information(_api::MarketApi; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = _oacinternal_exchange_information(_api; symbol=symbol, symbols=symbols, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function exchange_information(_api::MarketApi, response_stream::Channel; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = _oacinternal_exchange_information(_api; symbol=symbol, symbols=symbols, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_funding_rate_history_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{FundingRateResponseInner},
)

function _oacinternal_get_funding_rate_history(_api::MarketApi; symbol=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_funding_rate_history_MarketApi, "/fapi/v1/fundingRate", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get Funding Rate History

Get funding rate history  Weight: 1 

Params:
- symbol::String
- start_time::String
- end_time::String
- limit::String

Return: Vector{FundingRateResponseInner}, OpenAPI.Clients.ApiResponse
"""
function get_funding_rate_history(_api::MarketApi; symbol=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_funding_rate_history(_api; symbol=symbol, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_funding_rate_history(_api::MarketApi, response_stream::Channel; symbol=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_funding_rate_history(_api; symbol=symbol, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_historical_blvt_nav_kline_candlestick_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{Vector{KlinesResponseInnerInner}},
)

function _oacinternal_historical_blvt_nav_kline_candlestick(_api::MarketApi; symbol=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_historical_blvt_nav_kline_candlestick_MarketApi, "/fapi/v1/lvtKlines", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "interval", interval)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.header, "x-mbx-apikey", x_mbx_apikey)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Historical BLVT NAV Kline/Candlestick

Historical BLVT NAV Kline/Candlestick

Params:
- symbol::String
- interval::String
- start_time::String
- end_time::String
- limit::String
- x_mbx_apikey::String

Return: Vector{Vector{KlinesResponseInnerInner}}, OpenAPI.Clients.ApiResponse
"""
function historical_blvt_nav_kline_candlestick(_api::MarketApi; symbol=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_historical_blvt_nav_kline_candlestick(_api; symbol=symbol, interval=interval, start_time=start_time, end_time=end_time, limit=limit, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function historical_blvt_nav_kline_candlestick(_api::MarketApi, response_stream::Channel; symbol=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_historical_blvt_nav_kline_candlestick(_api; symbol=symbol, interval=interval, start_time=start_time, end_time=end_time, limit=limit, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_index_price_kline_candlestick_data_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{Vector{KlinesResponseInnerInner}},
)

function _oacinternal_index_price_kline_candlestick_data(_api::MarketApi; pair=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_index_price_kline_candlestick_data_MarketApi, "/fapi/v1/indexPriceKlines", [])
    OpenAPI.Clients.set_param(_ctx.query, "pair", pair)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "interval", interval)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Index Price Kline/Candlestick Data

Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.

Params:
- pair::String
- interval::String
- start_time::String
- end_time::String
- limit::String

Return: Vector{Vector{KlinesResponseInnerInner}}, OpenAPI.Clients.ApiResponse
"""
function index_price_kline_candlestick_data(_api::MarketApi; pair=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_index_price_kline_candlestick_data(_api; pair=pair, interval=interval, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function index_price_kline_candlestick_data(_api::MarketApi, response_stream::Channel; pair=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_index_price_kline_candlestick_data(_api; pair=pair, interval=interval, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_kline_candlestick_data_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{Vector{KlinesResponseInnerInner}},
)

function _oacinternal_kline_candlestick_data(_api::MarketApi, symbol::String, interval::String; start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    OpenAPI.validate_param("limit", "kline_candlestick_data", :maximum, limit, 1500, false)
    OpenAPI.validate_param("limit", "kline_candlestick_data", :minimum, limit, 1, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_kline_candlestick_data_MarketApi, "/fapi/v1/klines", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "interval", interval)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Kline/Candlestick Data

Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.

Params:
- symbol::String (required)
- interval::String (required)
- start_time::Int64
- end_time::Int64
- limit::Int64

Return: Vector{Vector{KlinesResponseInnerInner}}, OpenAPI.Clients.ApiResponse
"""
function kline_candlestick_data(_api::MarketApi, symbol::String, interval::String; start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_kline_candlestick_data(_api, symbol, interval; start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function kline_candlestick_data(_api::MarketApi, response_stream::Channel, symbol::String, interval::String; start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_kline_candlestick_data(_api, symbol, interval; start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_long_short_ratio_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_long_short_ratio(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_long_short_ratio_MarketApi, "/futures/data/globalLongShortAccountRatio", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "period", period)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.header, "x-mbx-apikey", x_mbx_apikey)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Long/Short Ratio

Get present open interest of a specific symbol.

Params:
- symbol::String
- period::String
- limit::String
- start_time::String
- end_time::String
- x_mbx_apikey::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function long_short_ratio(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_long_short_ratio(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function long_short_ratio(_api::MarketApi, response_stream::Channel; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_long_short_ratio(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_mark_price_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{PremiumIndexResponseInner},
)

function _oacinternal_mark_price(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_mark_price_MarketApi, "/fapi/v1/premiumIndex", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Mark Price

Mark Price and Funding Rate  Weight: 1 

Params:
- symbol::String

Return: Vector{PremiumIndexResponseInner}, OpenAPI.Clients.ApiResponse
"""
function mark_price(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_mark_price(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function mark_price(_api::MarketApi, response_stream::Channel; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_mark_price(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_mark_price_kline_candlestick_data_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{Vector{KlinesResponseInnerInner}},
)

function _oacinternal_mark_price_kline_candlestick_data(_api::MarketApi; symbol=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_mark_price_kline_candlestick_data_MarketApi, "/fapi/v1/markPriceKlines", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "interval", interval)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Mark Price Kline/Candlestick Data

Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.

Params:
- symbol::String
- interval::String
- start_time::String
- end_time::String
- limit::String

Return: Vector{Vector{KlinesResponseInnerInner}}, OpenAPI.Clients.ApiResponse
"""
function mark_price_kline_candlestick_data(_api::MarketApi; symbol=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_mark_price_kline_candlestick_data(_api; symbol=symbol, interval=interval, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function mark_price_kline_candlestick_data(_api::MarketApi, response_stream::Channel; symbol=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_mark_price_kline_candlestick_data(_api; symbol=symbol, interval=interval, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_multi_assets_mode_asset_index_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_multi_assets_mode_asset_index(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_multi_assets_mode_asset_index_MarketApi, "/fapi/v1/assetIndex", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Multi-Assets Mode Asset Index

Multi-Assets Mode Asset Index

Params:
- symbol::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function multi_assets_mode_asset_index(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_multi_assets_mode_asset_index(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function multi_assets_mode_asset_index(_api::MarketApi, response_stream::Channel; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_multi_assets_mode_asset_index(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_old_trades_lookup_market_data_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{HistoricalTradesResponseInner},
)

function _oacinternal_old_trades_lookup_market_data(_api::MarketApi, symbol::String; limit=nothing, from_id=nothing, _mediaType=nothing)
    OpenAPI.validate_param("limit", "old_trades_lookup_market_data", :maximum, limit, 1000, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_old_trades_lookup_market_data_MarketApi, "/fapi/v1/historicalTrades", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "fromId", from_id)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Old Trades Lookup (MARKET_DATA)

This endpoint need your API key only, not the secret key.

Params:
- symbol::String (required)
- limit::Int64
- from_id::Int64

Return: Vector{HistoricalTradesResponseInner}, OpenAPI.Clients.ApiResponse
"""
function old_trades_lookup_market_data(_api::MarketApi, symbol::String; limit=nothing, from_id=nothing, _mediaType=nothing)
    _ctx = _oacinternal_old_trades_lookup_market_data(_api, symbol; limit=limit, from_id=from_id, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function old_trades_lookup_market_data(_api::MarketApi, response_stream::Channel, symbol::String; limit=nothing, from_id=nothing, _mediaType=nothing)
    _ctx = _oacinternal_old_trades_lookup_market_data(_api, symbol; limit=limit, from_id=from_id, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_open_interest_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_open_interest(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_open_interest_MarketApi, "/fapi/v1/openInterest", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Open Interest

Get present open interest of a specific symbol.

Params:
- symbol::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function open_interest(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_open_interest(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function open_interest(_api::MarketApi, response_stream::Channel; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_open_interest(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_open_interest_statistics_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_open_interest_statistics(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_open_interest_statistics_MarketApi, "/futures/data/openInterestHist", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "period", period)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.header, "x-mbx-apikey", x_mbx_apikey)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Open Interest Statistics

Get present open interest of a specific symbol.

Params:
- symbol::String
- period::String
- limit::String
- start_time::String
- end_time::String
- x_mbx_apikey::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function open_interest_statistics(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_open_interest_statistics(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function open_interest_statistics(_api::MarketApi, response_stream::Channel; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_open_interest_statistics(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_order_book_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_order_book(_api::MarketApi, symbol::String; limit=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_order_book_MarketApi, "/fapi/v1/depth", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Order Book

Order Book 

Params:
- symbol::String (required)
- limit::Int64

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function order_book(_api::MarketApi, symbol::String; limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_order_book(_api, symbol; limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function order_book(_api::MarketApi, response_stream::Channel, symbol::String; limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_order_book(_api, symbol; limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_query_index_price_constituents_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_query_index_price_constituents(_api::MarketApi; symbol=nothing, pair=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_query_index_price_constituents_MarketApi, "/fapi/v1/constituents", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pair", pair)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Query Index Price Constituents

Query Index Price Constituents

Params:
- symbol::String
- pair::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function query_index_price_constituents(_api::MarketApi; symbol=nothing, pair=nothing, _mediaType=nothing)
    _ctx = _oacinternal_query_index_price_constituents(_api; symbol=symbol, pair=pair, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function query_index_price_constituents(_api::MarketApi, response_stream::Channel; symbol=nothing, pair=nothing, _mediaType=nothing)
    _ctx = _oacinternal_query_index_price_constituents(_api; symbol=symbol, pair=pair, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_recent_trades_list_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_recent_trades_list(_api::MarketApi, symbol::String; limit=nothing, _mediaType=nothing)
    OpenAPI.validate_param("limit", "recent_trades_list", :maximum, limit, 1000, false)
    OpenAPI.validate_param("limit", "recent_trades_list", :minimum, limit, 1, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_recent_trades_list_MarketApi, "/fapi/v1/trades", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Recent Trades List

Recent Trades List

Params:
- symbol::String (required)
- limit::Int64

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function recent_trades_list(_api::MarketApi, symbol::String; limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_recent_trades_list(_api, symbol; limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function recent_trades_list(_api::MarketApi, response_stream::Channel, symbol::String; limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_recent_trades_list(_api, symbol; limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_symbol_order_book_ticker_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{BookTickerResponseInner},
)

function _oacinternal_symbol_order_book_ticker(_api::MarketApi; symbol=nothing, symbols=nothing, _mediaType=nothing)
    OpenAPI.validate_param("symbols", "symbol_order_book_ticker", :maxItems, symbols, 100)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_symbol_order_book_ticker_MarketApi, "/fapi/v1/ticker/bookTicker", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "symbols", symbols)  # type Vector{String}
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Symbol Order Book Ticker

Best price/qty on the order book for a symbol or symbols.

Params:
- symbol::String
- symbols::Vector{String}

Return: Vector{BookTickerResponseInner}, OpenAPI.Clients.ApiResponse
"""
function symbol_order_book_ticker(_api::MarketApi; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = _oacinternal_symbol_order_book_ticker(_api; symbol=symbol, symbols=symbols, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function symbol_order_book_ticker(_api::MarketApi, response_stream::Channel; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = _oacinternal_symbol_order_book_ticker(_api; symbol=symbol, symbols=symbols, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_symbol_price_ticker_v2_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{SymbolPriceTickerResponseInner},
)

function _oacinternal_symbol_price_ticker_v2(_api::MarketApi; symbol=nothing, symbols=nothing, _mediaType=nothing)
    OpenAPI.validate_param("symbols", "symbol_price_ticker_v2", :maxItems, symbols, 100)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_symbol_price_ticker_v2_MarketApi, "/fapi/v2/ticker/price", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "symbols", symbols)  # type Vector{String}
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Symbol Price Ticker V2

Latest price for a symbol or symbols.

Params:
- symbol::String
- symbols::Vector{String}

Return: Vector{SymbolPriceTickerResponseInner}, OpenAPI.Clients.ApiResponse
"""
function symbol_price_ticker_v2(_api::MarketApi; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = _oacinternal_symbol_price_ticker_v2(_api; symbol=symbol, symbols=symbols, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function symbol_price_ticker_v2(_api::MarketApi, response_stream::Channel; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = _oacinternal_symbol_price_ticker_v2(_api; symbol=symbol, symbols=symbols, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_taker_buy_sell_volume_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_taker_buy_sell_volume(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_taker_buy_sell_volume_MarketApi, "/futures/data/takerlongshortRatio", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "period", period)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.header, "x-mbx-apikey", x_mbx_apikey)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Taker Buy/Sell Volume

Taker Buy/Sell Volume

Params:
- symbol::String
- period::String
- limit::String
- start_time::String
- end_time::String
- x_mbx_apikey::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function taker_buy_sell_volume(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_taker_buy_sell_volume(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function taker_buy_sell_volume(_api::MarketApi, response_stream::Channel; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_taker_buy_sell_volume(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_test_connectivity_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_test_connectivity(_api::MarketApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_test_connectivity_MarketApi, "/fapi/v1/ping", [])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Test Connectivity

Test connectivity to the Rest API. 

Params:

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function test_connectivity(_api::MarketApi; _mediaType=nothing)
    _ctx = _oacinternal_test_connectivity(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function test_connectivity(_api::MarketApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_test_connectivity(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_ticker_price_change_statistics24hr_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{TickerPriceChangeResponseInner},
)

function _oacinternal_ticker_price_change_statistics24hr(_api::MarketApi; symbol=nothing, symbols=nothing, _mediaType=nothing)
    OpenAPI.validate_param("symbols", "ticker_price_change_statistics24hr", :maxItems, symbols, 100)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_ticker_price_change_statistics24hr_MarketApi, "/fapi/v1/ticker/24hr", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "symbols", symbols)  # type Vector{String}
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""24hr Ticker Price Change Statistics

24 hour rolling window price change statistics.  Careful when accessing this with no symbol.  Weight:  1 for a single symbol;  40 when the symbol parameter is omitted 

Params:
- symbol::String
- symbols::Vector{String}

Return: Vector{TickerPriceChangeResponseInner}, OpenAPI.Clients.ApiResponse
"""
function ticker_price_change_statistics24hr(_api::MarketApi; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = _oacinternal_ticker_price_change_statistics24hr(_api; symbol=symbol, symbols=symbols, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function ticker_price_change_statistics24hr(_api::MarketApi, response_stream::Channel; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = _oacinternal_ticker_price_change_statistics24hr(_api; symbol=symbol, symbols=symbols, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_top_trader_long_short_ratio_accounts_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_top_trader_long_short_ratio_accounts(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_top_trader_long_short_ratio_accounts_MarketApi, "/futures/data/topLongShortAccountRatio", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "period", period)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Top Trader Long/Short Ratio (Accounts)

Get present open interest of a specific symbol.

Params:
- symbol::String
- period::String
- limit::String
- start_time::String
- end_time::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function top_trader_long_short_ratio_accounts(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_top_trader_long_short_ratio_accounts(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function top_trader_long_short_ratio_accounts(_api::MarketApi, response_stream::Channel; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_top_trader_long_short_ratio_accounts(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_top_trader_long_short_ratio_positions_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_top_trader_long_short_ratio_positions(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_top_trader_long_short_ratio_positions_MarketApi, "/futures/data/topLongShortPositionRatio", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "period", period)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Top Trader Long/Short Ratio (Positions)

Get present open interest of a specific symbol.

Params:
- symbol::String
- period::String
- limit::String
- start_time::String
- end_time::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function top_trader_long_short_ratio_positions(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_top_trader_long_short_ratio_positions(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function top_trader_long_short_ratio_positions(_api::MarketApi, response_stream::Channel; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_top_trader_long_short_ratio_positions(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

export basis
export check_server_time
export composite_index_symbol_information
export compressed_aggregate_trades_list
export continuous_contract_kline_candlestick_data
export exchange_information
export get_funding_rate_history
export historical_blvt_nav_kline_candlestick
export index_price_kline_candlestick_data
export kline_candlestick_data
export long_short_ratio
export mark_price
export mark_price_kline_candlestick_data
export multi_assets_mode_asset_index
export old_trades_lookup_market_data
export open_interest
export open_interest_statistics
export order_book
export query_index_price_constituents
export recent_trades_list
export symbol_order_book_ticker
export symbol_price_ticker_v2
export taker_buy_sell_volume
export test_connectivity
export ticker_price_change_statistics24hr
export top_trader_long_short_ratio_accounts
export top_trader_long_short_ratio_positions
