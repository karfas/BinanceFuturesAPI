# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.

struct MarketApi <: OpenAPI.APIClientImpl
    client::OpenAPI.Clients.Client
end

"""
The default API base path for APIs in `MarketApi`.
This can be used to construct the `OpenAPI.Clients.Client` instance.
"""
basepath(::Type{ MarketApi }) = "https://fapi.binance.com"

const _returntypes_agg_trades_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{AggregateTradesResponseInner},
)

function _oacinternal_agg_trades(_api::MarketApi, symbol::String; from_id=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    OpenAPI.validate_param("limit", "agg_trades", :maximum, limit, 1000, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_agg_trades_MarketApi, "/fapi/v1/aggTrades", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "fromId", from_id)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Compressed/Aggregate Trades List

Get compressed, aggregate trades. Trades that fill at the same time, from the same order, with the same price will have the quantity aggregated.

Params:
- symbol::String (required)
- from_id::Int64
- start_time::Int64
- end_time::Int64
- limit::Int64

Return: Vector{AggregateTradesResponseInner}, OpenAPI.Clients.ApiResponse
"""
function agg_trades(_api::MarketApi, symbol::String; from_id=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_agg_trades(_api, symbol; from_id=from_id, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function agg_trades(_api::MarketApi, response_stream::Channel, symbol::String; from_id=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_agg_trades(_api, symbol; from_id=from_id, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_asset_index_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_asset_index(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_asset_index_MarketApi, "/fapi/v1/assetIndex", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Multi-Assets Mode Asset Index

Multi-Assets Mode Asset Index

Params:
- symbol::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function asset_index(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_asset_index(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function asset_index(_api::MarketApi, response_stream::Channel; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_asset_index(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_basis_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_basis(_api::MarketApi; pair=nothing, contract_type=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_basis_MarketApi, "/fapi/v1/basis", [])
    OpenAPI.Clients.set_param(_ctx.query, "pair", pair)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "contractType", contract_type)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "period", period)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Basis

Basis

Params:
- pair::String
- contract_type::String
- period::String
- limit::String
- start_time::String
- end_time::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function basis(_api::MarketApi; pair=nothing, contract_type=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_basis(_api; pair=pair, contract_type=contract_type, period=period, limit=limit, start_time=start_time, end_time=end_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function basis(_api::MarketApi, response_stream::Channel; pair=nothing, contract_type=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_basis(_api; pair=pair, contract_type=contract_type, period=period, limit=limit, start_time=start_time, end_time=end_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_book_ticker_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BookTicker200Response,
)

function _oacinternal_book_ticker(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_book_ticker_MarketApi, "/fapi/v1/ticker/bookTicker", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Symbol Order Book Ticker

Best price/qty on the order book for a symbol or symbols.

Params:
- symbol::String

Return: BookTicker200Response, OpenAPI.Clients.ApiResponse
"""
function book_ticker(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_book_ticker(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function book_ticker(_api::MarketApi, response_stream::Channel; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_book_ticker(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_constituents_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_constituents(_api::MarketApi; symbol=nothing, pair=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_constituents_MarketApi, "/fapi/v1/constituents", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "pair", pair)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Query Index Price Constituents

Query Index Price Constituents

Params:
- symbol::String
- pair::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function constituents(_api::MarketApi; symbol=nothing, pair=nothing, _mediaType=nothing)
    _ctx = _oacinternal_constituents(_api; symbol=symbol, pair=pair, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function constituents(_api::MarketApi, response_stream::Channel; symbol=nothing, pair=nothing, _mediaType=nothing)
    _ctx = _oacinternal_constituents(_api; symbol=symbol, pair=pair, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_continuous_klines_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{Vector{KlinesResponseInnerInner}},
)

function _oacinternal_continuous_klines(_api::MarketApi; pair=nothing, contract_type=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_continuous_klines_MarketApi, "/fapi/v1/continuousKlines", [])
    OpenAPI.Clients.set_param(_ctx.query, "pair", pair)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "contractType", contract_type)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "interval", interval)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Continuous Contract Kline/Candlestick Data

Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.

Params:
- pair::String
- contract_type::String
- interval::String
- start_time::String
- end_time::String
- limit::String

Return: Vector{Vector{KlinesResponseInnerInner}}, OpenAPI.Clients.ApiResponse
"""
function continuous_klines(_api::MarketApi; pair=nothing, contract_type=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_continuous_klines(_api; pair=pair, contract_type=contract_type, interval=interval, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function continuous_klines(_api::MarketApi, response_stream::Channel; pair=nothing, contract_type=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_continuous_klines(_api; pair=pair, contract_type=contract_type, interval=interval, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_depth_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Depth200Response,
)

function _oacinternal_depth(_api::MarketApi, symbol::String; limit=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_depth_MarketApi, "/fapi/v1/depth", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Order Book

Order Book 

Params:
- symbol::String (required)
- limit::Int64

Return: Depth200Response, OpenAPI.Clients.ApiResponse
"""
function depth(_api::MarketApi, symbol::String; limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_depth(_api, symbol; limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function depth(_api::MarketApi, response_stream::Channel, symbol::String; limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_depth(_api, symbol; limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_exchange_info_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ExchangeInfoResponse,
)

function _oacinternal_exchange_info(_api::MarketApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_exchange_info_MarketApi, "/fapi/v1/exchangeInfo", [])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Exchange Information

Exchange Information 

Params:

Return: ExchangeInfoResponse, OpenAPI.Clients.ApiResponse
"""
function exchange_info(_api::MarketApi; _mediaType=nothing)
    _ctx = _oacinternal_exchange_info(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function exchange_info(_api::MarketApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_exchange_info(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_funding_rate_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{FundingRateResponseInner},
)

function _oacinternal_funding_rate(_api::MarketApi; symbol=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_funding_rate_MarketApi, "/fapi/v1/fundingRate", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get Funding Rate History

Get funding rate history  Weight: 1 

Params:
- symbol::String
- start_time::String
- end_time::String
- limit::String

Return: Vector{FundingRateResponseInner}, OpenAPI.Clients.ApiResponse
"""
function funding_rate(_api::MarketApi; symbol=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_funding_rate(_api; symbol=symbol, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function funding_rate(_api::MarketApi, response_stream::Channel; symbol=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_funding_rate(_api; symbol=symbol, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_global_long_short_account_ratio_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_global_long_short_account_ratio(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_global_long_short_account_ratio_MarketApi, "/fapi/v1/globalLongShortAccountRatio", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "period", period)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.header, "x-mbx-apikey", x_mbx_apikey)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Long/Short Ratio

Get present open interest of a specific symbol.

Params:
- symbol::String
- period::String
- limit::String
- start_time::String
- end_time::String
- x_mbx_apikey::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function global_long_short_account_ratio(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_global_long_short_account_ratio(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function global_long_short_account_ratio(_api::MarketApi, response_stream::Channel; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_global_long_short_account_ratio(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_historical_trades_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{HistoricalTradesResponseInner},
)

function _oacinternal_historical_trades(_api::MarketApi, symbol::String; limit=nothing, from_id=nothing, _mediaType=nothing)
    OpenAPI.validate_param("limit", "historical_trades", :maximum, limit, 1000, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_historical_trades_MarketApi, "/fapi/v1/historicalTrades", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "fromId", from_id)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Old Trades Lookup (MARKET_DATA)

This endpoint need your API key only, not the secret key.

Params:
- symbol::String (required)
- limit::Int64
- from_id::Int64

Return: Vector{HistoricalTradesResponseInner}, OpenAPI.Clients.ApiResponse
"""
function historical_trades(_api::MarketApi, symbol::String; limit=nothing, from_id=nothing, _mediaType=nothing)
    _ctx = _oacinternal_historical_trades(_api, symbol; limit=limit, from_id=from_id, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function historical_trades(_api::MarketApi, response_stream::Channel, symbol::String; limit=nothing, from_id=nothing, _mediaType=nothing)
    _ctx = _oacinternal_historical_trades(_api, symbol; limit=limit, from_id=from_id, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_index_info_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_index_info(_api::MarketApi; symbol=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_index_info_MarketApi, "/fapi/v1/indexInfo", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.header, "x-mbx-apikey", x_mbx_apikey)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Composite Index Symbol Information

Composite Index Symbol Information

Params:
- symbol::String
- x_mbx_apikey::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function index_info(_api::MarketApi; symbol=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_index_info(_api; symbol=symbol, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function index_info(_api::MarketApi, response_stream::Channel; symbol=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_index_info(_api; symbol=symbol, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_index_price_klines_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{Vector{KlinesResponseInnerInner}},
)

function _oacinternal_index_price_klines(_api::MarketApi; pair=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_index_price_klines_MarketApi, "/fapi/v1/indexPriceKlines", [])
    OpenAPI.Clients.set_param(_ctx.query, "pair", pair)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "interval", interval)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Index Price Kline/Candlestick Data

Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.

Params:
- pair::String
- interval::String
- start_time::String
- end_time::String
- limit::String

Return: Vector{Vector{KlinesResponseInnerInner}}, OpenAPI.Clients.ApiResponse
"""
function index_price_klines(_api::MarketApi; pair=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_index_price_klines(_api; pair=pair, interval=interval, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function index_price_klines(_api::MarketApi, response_stream::Channel; pair=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_index_price_klines(_api; pair=pair, interval=interval, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_klines_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{Vector{KlinesResponseInnerInner}},
)

function _oacinternal_klines(_api::MarketApi, symbol::String, interval::String; start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    OpenAPI.validate_param("limit", "klines", :maximum, limit, 1500, false)
    OpenAPI.validate_param("limit", "klines", :minimum, limit, 1, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_klines_MarketApi, "/fapi/v1/klines", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "interval", interval)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Kline/Candlestick Data

Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.

Params:
- symbol::String (required)
- interval::String (required)
- start_time::Int64
- end_time::Int64
- limit::Int64

Return: Vector{Vector{KlinesResponseInnerInner}}, OpenAPI.Clients.ApiResponse
"""
function klines(_api::MarketApi, symbol::String, interval::String; start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_klines(_api, symbol, interval; start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function klines(_api::MarketApi, response_stream::Channel, symbol::String, interval::String; start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_klines(_api, symbol, interval; start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_lvt_klines_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{Vector{KlinesResponseInnerInner}},
)

function _oacinternal_lvt_klines(_api::MarketApi; symbol=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_lvt_klines_MarketApi, "/fapi/v1/lvtKlines", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "interval", interval)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.header, "x-mbx-apikey", x_mbx_apikey)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Historical BLVT NAV Kline/Candlestick

Historical BLVT NAV Kline/Candlestick

Params:
- symbol::String
- interval::String
- start_time::String
- end_time::String
- limit::String
- x_mbx_apikey::String

Return: Vector{Vector{KlinesResponseInnerInner}}, OpenAPI.Clients.ApiResponse
"""
function lvt_klines(_api::MarketApi; symbol=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_lvt_klines(_api; symbol=symbol, interval=interval, start_time=start_time, end_time=end_time, limit=limit, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function lvt_klines(_api::MarketApi, response_stream::Channel; symbol=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_lvt_klines(_api; symbol=symbol, interval=interval, start_time=start_time, end_time=end_time, limit=limit, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_mark_price_klines_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{Vector{KlinesResponseInnerInner}},
)

function _oacinternal_mark_price_klines(_api::MarketApi; symbol=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_mark_price_klines_MarketApi, "/fapi/v1/markPriceKlines", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "interval", interval)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Mark Price Kline/Candlestick Data

Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by their open time.

Params:
- symbol::String
- interval::String
- start_time::String
- end_time::String
- limit::String

Return: Vector{Vector{KlinesResponseInnerInner}}, OpenAPI.Clients.ApiResponse
"""
function mark_price_klines(_api::MarketApi; symbol=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_mark_price_klines(_api; symbol=symbol, interval=interval, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function mark_price_klines(_api::MarketApi, response_stream::Channel; symbol=nothing, interval=nothing, start_time=nothing, end_time=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_mark_price_klines(_api; symbol=symbol, interval=interval, start_time=start_time, end_time=end_time, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_open_interest_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_open_interest(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_open_interest_MarketApi, "/fapi/v1/openInterest", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Open Interest

Get present open interest of a specific symbol.

Params:
- symbol::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function open_interest(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_open_interest(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function open_interest(_api::MarketApi, response_stream::Channel; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_open_interest(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_open_interest_hist_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_open_interest_hist(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_open_interest_hist_MarketApi, "/futures/data/openInterestHist", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "period", period)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.header, "x-mbx-apikey", x_mbx_apikey)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Open Interest Statistics

Get present open interest of a specific symbol.

Params:
- symbol::String
- period::String
- limit::String
- start_time::String
- end_time::String
- x_mbx_apikey::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function open_interest_hist(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_open_interest_hist(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function open_interest_hist(_api::MarketApi, response_stream::Channel; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_open_interest_hist(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_ping_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_ping(_api::MarketApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_ping_MarketApi, "/fapi/v1/ping", [])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Test Connectivity

Test connectivity to the Rest API. 

Params:

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function ping(_api::MarketApi; _mediaType=nothing)
    _ctx = _oacinternal_ping(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function ping(_api::MarketApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_ping(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_premium_index_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{PremiumIndexResponseInner},
)

function _oacinternal_premium_index(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_premium_index_MarketApi, "/fapi/v1/premiumIndex", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Mark Price

Mark Price and Funding Rate  Weight: 1 

Params:
- symbol::String

Return: Vector{PremiumIndexResponseInner}, OpenAPI.Clients.ApiResponse
"""
function premium_index(_api::MarketApi; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_premium_index(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function premium_index(_api::MarketApi, response_stream::Channel; symbol=nothing, _mediaType=nothing)
    _ctx = _oacinternal_premium_index(_api; symbol=symbol, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_server_time_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ServerTime200Response,
)

function _oacinternal_server_time(_api::MarketApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_server_time_MarketApi, "/fapi/v1/time", [])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Check Server Time

Check Server Time 

Params:

Return: ServerTime200Response, OpenAPI.Clients.ApiResponse
"""
function server_time(_api::MarketApi; _mediaType=nothing)
    _ctx = _oacinternal_server_time(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function server_time(_api::MarketApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_server_time(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_taker_long_short_ratio_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_taker_long_short_ratio(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_taker_long_short_ratio_MarketApi, "/fapi/v1/takerlongshortRatio", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "period", period)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_param(_ctx.header, "x-mbx-apikey", x_mbx_apikey)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Taker Buy/Sell Volume

Taker Buy/Sell Volume

Params:
- symbol::String
- period::String
- limit::String
- start_time::String
- end_time::String
- x_mbx_apikey::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function taker_long_short_ratio(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_taker_long_short_ratio(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function taker_long_short_ratio(_api::MarketApi, response_stream::Channel; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, x_mbx_apikey=nothing, _mediaType=nothing)
    _ctx = _oacinternal_taker_long_short_ratio(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, x_mbx_apikey=x_mbx_apikey, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_ticker24hr_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Ticker24hr200Response,
)

function _oacinternal_ticker24hr(_api::MarketApi; symbol=nothing, symbols=nothing, _mediaType=nothing)
    OpenAPI.validate_param("symbols", "ticker24hr", :maxItems, symbols, 100)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_ticker24hr_MarketApi, "/fapi/v1/ticker/24hr", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "symbols", symbols)  # type Vector{String}
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""24hr Ticker Price Change Statistics

24 hour rolling window price change statistics.  Careful when accessing this with no symbol.  Weight:  1 for a single symbol;  40 when the symbol parameter is omitted 

Params:
- symbol::String
- symbols::Vector{String}

Return: Ticker24hr200Response, OpenAPI.Clients.ApiResponse
"""
function ticker24hr(_api::MarketApi; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = _oacinternal_ticker24hr(_api; symbol=symbol, symbols=symbols, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function ticker24hr(_api::MarketApi, response_stream::Channel; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = _oacinternal_ticker24hr(_api; symbol=symbol, symbols=symbols, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_ticker_price_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{SymbolPriceTickerResponseInner},
)

function _oacinternal_ticker_price(_api::MarketApi; symbol=nothing, symbols=nothing, _mediaType=nothing)
    OpenAPI.validate_param("symbols", "ticker_price", :maxItems, symbols, 100)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_ticker_price_MarketApi, "/fapi/v2/ticker/price", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "symbols", symbols)  # type Vector{String}
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Symbol Price Ticker V2

Latest price for a symbol or symbols.

Params:
- symbol::String
- symbols::Vector{String}

Return: Vector{SymbolPriceTickerResponseInner}, OpenAPI.Clients.ApiResponse
"""
function ticker_price(_api::MarketApi; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = _oacinternal_ticker_price(_api; symbol=symbol, symbols=symbols, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function ticker_price(_api::MarketApi, response_stream::Channel; symbol=nothing, symbols=nothing, _mediaType=nothing)
    _ctx = _oacinternal_ticker_price(_api; symbol=symbol, symbols=symbols, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_top_long_short_account_ratio_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_top_long_short_account_ratio(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_top_long_short_account_ratio_MarketApi, "/fapi/v1/topLongShortAccountRatio", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "period", period)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Top Trader Long/Short Ratio (Accounts)

Get present open interest of a specific symbol.

Params:
- symbol::String
- period::String
- limit::String
- start_time::String
- end_time::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function top_long_short_account_ratio(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_top_long_short_account_ratio(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function top_long_short_account_ratio(_api::MarketApi, response_stream::Channel; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_top_long_short_account_ratio(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_top_long_short_position_ratio_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_top_long_short_position_ratio(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_top_long_short_position_ratio_MarketApi, "/fapi/v1/topLongShortPositionRatio", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "period", period)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "startTime", start_time)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "endTime", end_time)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Top Trader Long/Short Ratio (Positions)

Get present open interest of a specific symbol.

Params:
- symbol::String
- period::String
- limit::String
- start_time::String
- end_time::String

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function top_long_short_position_ratio(_api::MarketApi; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_top_long_short_position_ratio(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function top_long_short_position_ratio(_api::MarketApi, response_stream::Channel; symbol=nothing, period=nothing, limit=nothing, start_time=nothing, end_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_top_long_short_position_ratio(_api; symbol=symbol, period=period, limit=limit, start_time=start_time, end_time=end_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_trades_MarketApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, Any},
)

function _oacinternal_trades(_api::MarketApi, symbol::String; limit=nothing, _mediaType=nothing)
    OpenAPI.validate_param("limit", "trades", :maximum, limit, 1000, false)
    OpenAPI.validate_param("limit", "trades", :minimum, limit, 1, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_trades_MarketApi, "/fapi/v1/trades", [])
    OpenAPI.Clients.set_param(_ctx.query, "symbol", symbol)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Recent Trades List

Recent Trades List

Params:
- symbol::String (required)
- limit::Int64

Return: Dict{String, Any}, OpenAPI.Clients.ApiResponse
"""
function trades(_api::MarketApi, symbol::String; limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_trades(_api, symbol; limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function trades(_api::MarketApi, response_stream::Channel, symbol::String; limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_trades(_api, symbol; limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

export agg_trades
export asset_index
export basis
export book_ticker
export constituents
export continuous_klines
export depth
export exchange_info
export funding_rate
export global_long_short_account_ratio
export historical_trades
export index_info
export index_price_klines
export klines
export lvt_klines
export mark_price_klines
export open_interest
export open_interest_hist
export ping
export premium_index
export server_time
export taker_long_short_ratio
export ticker24hr
export ticker_price
export top_long_short_account_ratio
export top_long_short_position_ratio
export trades
